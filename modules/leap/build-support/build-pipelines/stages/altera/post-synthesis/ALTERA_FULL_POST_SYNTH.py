import os
import re
import sys
import SCons.Script
import model
import synthesis_library 

class PostSynthesize():

    def __init__(self, moduleList):
        altera_apm_name = moduleList.compileDirectory + '/' + moduleList.apmName

        #synthDeps = moduleList.topModule.moduleDependency['SYNTHESIS']

        # pick up awb parameters.
        paramTclFile = moduleList.topModule.moduleDependency['PARAM_TCL'][0]

        timingReportScript =  moduleList.apmName + '.sta.sdc'

        timingReportScriptFile = open(moduleList.compileDirectory + '/'  + timingReportScript, 'w')
        timingReportScriptFile.write('report_timing -file ' + moduleList.apmName + '.twr\n')
        timingReportScriptFile.write('report_exceptions  -file ' +  moduleList.apmName + '.twr\n')
        timingReportScriptFile.close()

        newPrjFile = open(altera_apm_name + '.temp.qsf', 'w')


        # Add in all the verilog here. 
        [globalVerilogs, globalVHDs] = synthesis_library.globalRTLs(moduleList, moduleList.moduleList)
         

        # gather verilog for LI Modules. 
        for module in [ mod for mod in moduleList.synthBoundaries()] + [moduleList.topModule]:
            globalVerilogs += [model.get_temp_path(moduleList,module) + module.wrapperName() + '.v']

        # Write files to the quartus project file. Due to a bug in the STA tool, we need to execute 
        # Quartus from the compileDirectory. This means we have to rebase all of the files.

        for v in globalVerilogs:
            newPrjFile.write('set_global_assignment -name VERILOG_FILE ' +  model.rel_if_not_abspath(v, moduleList.compileDirectory) + '\n'); 


        for v in globalVHDs:
            newPrjFile.write('set_global_assignment -name VHDL_FILE ' + model.rel_if_not_abspath(v, moduleList.compileDirectory) + '\n'); 

        print " Compile directory : " + moduleList.compileDirectory

        # add the verilogs of the files generated by quartus system builder
        for v in model.Utils.clean_split(moduleList.env['DEFS']['GIVEN_ALTERAVS'], sep = ' ') :
            newPrjFile.write('set_global_assignment -name VERILOG_FILE ' +  model.rel_if_not_abspath(v, moduleList.compileDirectory) + '\n'); 

        # Include SDC (Tcl) files. These must be included in a specific order to honor dependencies among them.
        sdcs = map(model.modify_path_hw, moduleList.getAllDependenciesWithPaths('GIVEN_TCL_HEADERS')) + map(model.modify_path_hw, moduleList.getAllDependenciesWithPaths('GIVEN_SDCS')) + map(model.modify_path_hw, moduleList.getAllDependenciesWithPaths('GIVEN_SDC_ALGEBRAS'))      

        for tcl_header in [paramTclFile] + sdcs:
            newPrjFile.write('set_global_assignment -name SDC_FILE ' + model.rel_if_not_abspath(tcl_header, moduleList.compileDirectory)+ '\n')

        newPrjFile.write('set_global_assignment -name TOP_LEVEL_ENTITY ' + moduleList.topModule.wrapperName() + '\n')
        newPrjFile.close()

        # Concatenate altera QSF files
        altera_qsf = moduleList.env.Command(
          altera_apm_name + '.qsf',
          [altera_apm_name + '.temp.qsf'] + model.Utils.clean_split(moduleList.env['DEFS']['GIVEN_QSFS'], sep = ' '),
          ['cat $SOURCES > $TARGET',
           'rm ' + altera_apm_name + '.temp.qsf'])

        # generate sof
        altera_sof = moduleList.env.Command(altera_apm_name + '.sof',
                                            globalVerilogs + globalVHDs + [altera_qsf] + [paramTclFile] + sdcs,
                                            ['cd ' + moduleList.compileDirectory + '; quartus_map --verilog_macro="QUARTUS_COMPILATION=1" --lib_path=`pwd` ' + moduleList.apmName,
                                             'cd ' + moduleList.compileDirectory + '; quartus_fit ' + moduleList.apmName,
                                             'cd ' + moduleList.compileDirectory + '; quartus_sta ' + moduleList.apmName + ' --report_script=' + timingReportScript,
                                             'cd ' + moduleList.compileDirectory + '; quartus_asm ' + moduleList.apmName])

        moduleList.topModule.moduleDependency['BIT'] = [altera_sof]

        # generate the download program
        newDownloadFile = open('config/' + moduleList.apmName + '.download.temp', 'w')
        newDownloadFile.write('#!/bin/sh\n')
        newDownloadFile.write('nios2-configure-sof ' + altera_apm_name + '.sof\n')
        newDownloadFile.close()

        altera_download = moduleList.env.Command(
            'config/' + moduleList.apmName + '.download',
            'config/' + moduleList.apmName + '.download.temp',
            ['cp $SOURCE $TARGET',
             'chmod 755 $TARGET'])



        ##
        ## Generate a summary of the build and write a target file describing
        ## whether the build was successful.
        ## TODO: This code is almost identical to the Vivado code. Refactoring
        ##       is needed. 
        ##
        def leap_altera_summary(altera_apm_name):
            def leap_altera_summary_closure(target, source, env):
                par_file = open(altera_apm_name + '.sta.rpt','r')
                errinfo_file = open(str(target[0]), 'w')

                timing_score = None
                clk_err = 0

                for full_line in par_file:
                    line = full_line.rstrip()
                    # do a quartus specific search.   
                    match = re.search(r'Timing Analyzer was successful', line)
                    if (match):
                        timing_score = 0 

                    match = re.search(r'Timing requirements not met', line)
                    if (match):
                        timing_score = 1 
                        break
      
                par_file.close()

                if (timing_score is None):
                    print 'Failed to find timing score!'
                    clk_err = 1

                if (clk_err or timing_score > 0):
                    print '\n        ******** Design does NOT meet timing! ********\n'
                    errinfo_file.write('Slack was violated.\n')
                else:
                    print '\nDesign meets timing.'

                errinfo_file.close()

                # Timing failures are reported as non-fatal errors.  The error is
                # noted but the build continues.
                if (clk_err or timing_score > 0):
                    model.nonFatalFailures.append(str(target[0]))

            return leap_altera_summary_closure

                        
        altera_loader = moduleList.env.Command(
            moduleList.apmName + '_hw.errinfo',
            moduleList.swExe + moduleList.topModule.moduleDependency['BIT'] + altera_download,
            ['@ln -fs ' + moduleList.swExeOrTarget + ' ' + moduleList.apmName,
             SCons.Script.Delete(moduleList.apmName + '_hw.exe'),
             SCons.Script.Delete(moduleList.apmName + '_hw.vexe'),
             '@echo "++++++++++++ Post-Place & Route ++++++++"',
             leap_altera_summary(altera_apm_name)])

        moduleList.topModule.moduleDependency['LOADER'] = [altera_loader]
        moduleList.topDependency = moduleList.topDependency + [altera_loader]
