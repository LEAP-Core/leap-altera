import os
import re
import sys
import SCons.Script
import model
import synthesis_library 

class PostSynthesize():

    def __init__(self, moduleList):
        altera_apm_name = moduleList.compileDirectory + '/' + moduleList.apmName

        # pick up awb parameters.
        paramTclFile = moduleList.topModule.moduleDependency['PARAM_TCL'][0]

        # If the compilation directory doesn't exist, create it. 
        if(not os.path.exists(moduleList.compileDirectory)):
            os.mkdir(moduleList.compileDirectory)

        newPrjFile = open(altera_apm_name + '.tcl', 'w')

        newPrjFile.write('package require ::quartus::project\n')
        newPrjFile.write('package require ::quartus::flow\n')

        # do we want to check for the existence of a project here?
        newPrjFile.write('project_new ' + moduleList.apmName +' -overwrite\n')

        # Add in all the verilog here. 
        [globalVerilogs, globalVHDs] = synthesis_library.globalRTLs(moduleList, moduleList.moduleList)
         

        # gather verilog for LI Modules. 
        for module in [ mod for mod in moduleList.synthBoundaries()] + [moduleList.topModule]:
            globalVerilogs += [model.get_temp_path(moduleList,module) + module.wrapperName() + '.v']

        # Write files to the quartus project file. Due to a bug in the STA tool, we need to execute 
        # Quartus from the compileDirectory. This means we have to rebase all of the files.

        for v in globalVerilogs:
            newPrjFile.write('set_global_assignment -name VERILOG_FILE ' +  model.rel_if_not_abspath(v, moduleList.compileDirectory) + '\n'); 


        for v in globalVHDs:
            newPrjFile.write('set_global_assignment -name VHDL_FILE ' + model.rel_if_not_abspath(v, moduleList.compileDirectory) + '\n'); 

        for sysVerilogFile in moduleList.getAllDependenciesWithPaths('GIVEN_SYSTEM_VERILOGS')):
            newPrjFile.write('set_global_assignment -name SYSTEMVERILOG_FILE ' + model.rel_if_not_abspath(memFile, moduleList.compileDirectory)+ '\n')

        # Altera flows appear to accept some kinds of memory intialization files. 
        # incorporate them here.
        for memFile in map(model.modify_path_hw,moduleList.getAllDependenciesWithPaths('GIVEN_MIFS') + moduleList.getAllDependenciesWithPaths('GIVEN_MIFS')):
            newPrjFile.write('set_global_assignment -name SOURCE_FILE ' + model.rel_if_not_abspath(memFile, moduleList.compileDirectory)+ '\n')

        print " Compile directory : " + moduleList.compileDirectory

        # add the verilogs of the files generated by quartus system builder
        for v in model.Utils.clean_split(moduleList.env['DEFS']['GIVEN_ALTERAVS'], sep = ' ') :
            newPrjFile.write('set_global_assignment -name VERILOG_FILE ' +  model.rel_if_not_abspath(v, moduleList.compileDirectory) + '\n'); 

        # Include SDC (Tcl) files. These must be included in a specific order to honor dependencies among them.
        sdcs = map(model.modify_path_hw, moduleList.getAllDependenciesWithPaths('GIVEN_TCL_HEADERS')) + map(model.modify_path_hw, moduleList.getAllDependenciesWithPaths('GIVEN_SDCS')) + map(model.modify_path_hw, moduleList.getAllDependenciesWithPaths('GIVEN_SDC_ALGEBRAS'))      

        for tcl_header in [paramTclFile] + sdcs:
            newPrjFile.write('set_global_assignment -name SDC_FILE ' + model.rel_if_not_abspath(tcl_header, moduleList.compileDirectory)+ '\n')

        newPrjFile.write('set_global_assignment -name TOP_LEVEL_ENTITY ' + moduleList.topModule.wrapperName() + '\n')

        for qsf in map(model.modify_path_hw,moduleList.getAllDependenciesWithPaths('GIVEN_QSFS')):
            newPrjFile.write('source ' + model.rel_if_not_abspath(qsf, moduleList.compileDirectory)+ '\n')

        fullCompilePath = os.path.abspath(moduleList.compileDirectory)

        newPrjFile.write('execute_module  -tool map -args "--verilog_macro=\\"QUARTUS_COMPILATION=1\\" --lib_path ' + fullCompilePath + ' " \n')
        newPrjFile.write('execute_module  -tool fit \n')
        newPrjFile.write('execute_module  -tool sta \n')
        newPrjFile.write('execute_module  -tool sta -args "--do_report_timing"\n')
        newPrjFile.write('execute_module  -tool asm  \n')

        newPrjFile.write('project_close \n')
        newPrjFile.close()

        altera_sof = moduleList.env.Command(altera_apm_name + '.sof',
                                            globalVerilogs + globalVHDs + [altera_apm_name + '.tcl'] + [paramTclFile] + sdcs,
                                            ['cd ' + moduleList.compileDirectory + '; quartus_sh -t ' + moduleList.apmName + '.tcl' ])


        moduleList.topModule.moduleDependency['BIT'] = [altera_sof]

        # generate the download program
        newDownloadFile = open('config/' + moduleList.apmName + '.download.temp', 'w')
        newDownloadFile.write('#!/bin/sh\n')
        
        fpgaPosition = moduleList.getAWBParam('physical_platform_config', 'FPGA_POSITION')
        newDownloadFile.write('nios2-configure-sof --device ' + str(fpgaPosition) + ' ' +  altera_apm_name + '.sof\n')
        newDownloadFile.close()

        altera_download = moduleList.env.Command(
            'config/' + moduleList.apmName + '.download',
            'config/' + moduleList.apmName + '.download.temp',
            ['cp $SOURCE $TARGET',
             'chmod 755 $TARGET'])

        altera_loader = moduleList.env.Command(
            moduleList.apmName + '_hw.errinfo',
            moduleList.swExe + moduleList.topModule.moduleDependency['BIT'] + altera_download,
            ['@ln -fs ' + moduleList.swExeOrTarget + ' ' + moduleList.apmName,
             SCons.Script.Delete(moduleList.apmName + '_hw.exe'),
             SCons.Script.Delete(moduleList.apmName + '_hw.vexe'),
             '@echo "++++++++++++ Post-Place & Route ++++++++"',
             synthesis_library.leap_physical_summary(altera_apm_name + '.sta.rpt', moduleList.apmName + '_hw.errinfo', 'Timing Analyzer was successful', 'Timing requirements not met')])

        moduleList.topModule.moduleDependency['LOADER'] = [altera_loader]
        moduleList.topDependency = moduleList.topDependency + [altera_loader]
